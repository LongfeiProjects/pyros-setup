# -*- coding: utf-8 -*-
from __future__ import absolute_import

import importlib

"""
Small setup package to dynamically interface with ROS
"""
from ._version import __version__

import os
import types
import sys

# forcing minimal version for pyros_config (very important since we play with multiple python environments...)
# This should allow pkg_resources to go through multiple version fo the same package... Ref : http://bugs.python.org/setuptools/issue139
# but it seems not to work. more testing needed.
# __requires__ = [
#     "pyros_config>=0.2"
# ]
import pkg_resources
# This produces a version conflict if the imported version is not the correct one. Fix your distro.
pkg_resources.require("pyros_config>=0.2")

# Configuring logging default handler
import logging
_logger = logging.getLogger(__name__)

from pyros_config import ConfigHandler



"""
Configure access to a ros distro (using the instance path of this package).
This is designed after Flask instance configuration mechanism http://flask.pocoo.org/docs/0.10/config/#instance-folders
:param instance_path: path to the instance folder. defaults to a sensible 'instance' location (refer to Flask doc)
:param instance_relative_config: whether the configuration file is in the instance folder (or the root_path)
:param root_path: path to the application's folder
:return:
"""

#: Smart Default distro detection (as early as possible)
if os.path.exists('/opt/ros/kinetic'):
    distro = 'kinetic'
    distro_path = '/opt/ros/kinetic'
elif os.path.exists('/opt/ros/jade'):
    distro = 'jade'
    distro_path = '/opt/ros/jade'
elif os.path.exists('/opt/ros/indigo'):
    distro = 'indigo'
    distro_path = '/opt/ros/indigo'
else:
    distro = 'unknown'
    distro_path = 'unknown'


# we create a configuration (in our detected instance path) to point us to the correct distro
distro_config_handler = ConfigHandler(
    __name__,
    instance_path=None,
    instance_relative_config=True,
    root_path=None,
    default_config={
        'DISTRO': distro,
    },
)

distro_mod = importlib.import_module('.distro', package=__package__)  # relative import of submodule


def configure(self, config=None):
    """
    load configuration
    :param config:
        if string, it is assumed to be a path to a python configuration file
        else if dict, it is assumed to directly contain the configuration settings
        otherwise the object passed will be introspected to attempt to set the configuration settings.
    :return: self
    """

    config = config or 'pyros_setup.cfg'

    # TODO : maybe we can abuse the '.pth' system here ??
    # In full ros setup case, we only need a string OR path
    # In (TODO) import ros setup case, we probably can rely on .pth system...

    self.distro_config_handler.configure_file(config=config, create_if_missing="""
    # default configuration generated by pyros_setup.indigo
    # Usage from python :
    # import pyros_setup
    # pyros_setup.configurable_import().configure().activate()
    #
    # Fill in your workspaces here, if you want pyros_setup to dynamically import ROS packages from it.
    DISTRO={self.distro}
    """.format(**locals()))

    return self.distro_mod.configure(config)


def activate(self):
    """
    Activate import relay (via setting sys.modules[])
    :return: self
    """

    return self.distro_mod.activate()


__all__ = [
    '__version__',
]
